<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Anti-Fingerprint Protection Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .test-section:hover {
            border-color: #3498db;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.1);
        }

        .test-section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        .test-result {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .result-protected {
            background: #d5f4e6;
            border-left: 5px solid #27ae60;
            color: #27ae60;
        }

        .result-vulnerable {
            background: #ffeaa7;
            border-left: 5px solid #f39c12;
            color: #e67e22;
        }

        .result-exposed {
            background: #fab1a0;
            border-left: 5px solid #e74c3c;
            color: #c0392b;
        }

        .result-info {
            background: #dff9fb;
            border-left: 5px solid #00cec9;
            color: #00b894;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-protected { background: #27ae60; }
        .status-vulnerable { background: #f39c12; }
        .status-exposed { background: #e74c3c; }
        .status-info { background: #00cec9; }

        .test-canvas {
            border: 1px solid #ddd;
            margin: 10px 0;
        }

        .controls {
            margin: 20px 0;
            text-align: center;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #ecf0f1;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
        }

        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.5s ease;
        }

        .footer {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .content {
                padding: 20px;
            }
            
            .test-section {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è Anti-Fingerprint Protection Test</h1>
            <p>Comprehensive testing suite for Ultimate Anti-Fingerprint userscript</p>
        </div>

        <div class="content">
            <div class="controls">
                <button class="btn" onclick="runAllTests()">üöÄ Run All Tests</button>
                <button class="btn" onclick="clearResults()">üóëÔ∏è Clear Results</button>
                <button class="btn" onclick="exportResults()">üìä Export Results</button>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="protection-score">0%</div>
                    <div class="stat-label">Protection Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="tests-passed">0</div>
                    <div class="stat-label">Tests Passed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="fingerprint-attempts">0</div>
                    <div class="stat-label">Fingerprint Attempts</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="blocked-requests">0</div>
                    <div class="stat-label">Blocked Requests</div>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="overall-progress" style="width: 0%"></div>
            </div>

            <!-- Navigator & User Agent Tests -->
            <div class="test-section">
                <h2>üåê Navigator & User Agent Protection</h2>
                <div id="navigator-results"></div>
            </div>

            <!-- Canvas Fingerprinting Tests -->
            <div class="test-section">
                <h2>üé® Canvas Fingerprinting Protection</h2>
                <canvas id="test-canvas" class="test-canvas" width="200" height="100"></canvas>
                <div id="canvas-results"></div>
            </div>

            <!-- WebGL Fingerprinting Tests -->
            <div class="test-section">
                <h2>üéÆ WebGL Fingerprinting Protection</h2>
                <div id="webgl-results"></div>
            </div>

            <!-- Audio Fingerprinting Tests -->
            <div class="test-section">
                <h2>üîä Audio Context Protection</h2>
                <div id="audio-results"></div>
            </div>

            <!-- Font Fingerprinting Tests -->
            <div class="test-section">
                <h2>üî§ Font Fingerprinting Protection</h2>
                <div id="font-results"></div>
            </div>

            <!-- Screen & Hardware Tests -->
            <div class="test-section">
                <h2>üñ•Ô∏è Screen & Hardware Protection</h2>
                <div id="screen-results"></div>
            </div>

            <!-- Network & Privacy Tests -->
            <div class="test-section">
                <h2>üåê Network & Privacy Protection</h2>
                <div id="network-results"></div>
            </div>

            <!-- Tracking Protection Tests -->
            <div class="test-section">
                <h2>üö´ Tracking Protection</h2>
                <div id="tracking-results"></div>
            </div>
        </div>

        <div class="footer">
            <p>Ultimate Anti-Fingerprint Protection Test Suite v2.1 | 
               <a href="https://github.com/lulavc/ultimate-anti-fingerprint" style="color: #3498db;">GitHub</a></p>
        </div>
    </div>

    <script>
        class FingerprintTester {
            constructor() {
                this.results = {};
                this.testsPassed = 0;
                this.totalTests = 0;
                this.fingerprintAttempts = 0;
                this.blockedRequests = 0;
            }

            addResult(section, test, status, value, expected = null) {
                if (!this.results[section]) this.results[section] = [];
                
                this.results[section].push({
                    test,
                    status,
                    value,
                    expected
                });

                this.totalTests++;
                if (status === 'protected' || status === 'info') {
                    this.testsPassed++;
                }

                this.updateStats();
            }

            updateStats() {
                const protectionScore = Math.round((this.testsPassed / this.totalTests) * 100);
                document.getElementById('protection-score').textContent = protectionScore + '%';
                document.getElementById('tests-passed').textContent = this.testsPassed;
                document.getElementById('fingerprint-attempts').textContent = this.fingerprintAttempts;
                document.getElementById('blocked-requests').textContent = this.blockedRequests;
                document.getElementById('overall-progress').style.width = protectionScore + '%';
            }

            renderResults(section, containerId) {
                const container = document.getElementById(containerId);
                const results = this.results[section] || [];
                
                container.innerHTML = results.map(result => {
                    const statusClass = `result-${result.status}`;
                    const indicatorClass = `status-${result.status}`;
                    const statusIcon = result.status === 'protected' ? '‚úÖ' : 
                                     result.status === 'vulnerable' ? '‚ö†Ô∏è' : 
                                     result.status === 'exposed' ? '‚ùå' : '‚ÑπÔ∏è';
                    
                    return `
                        <div class="test-result ${statusClass}">
                            <span class="status-indicator ${indicatorClass}"></span>
                            ${statusIcon} <strong>${result.test}:</strong><br>
                            Value: ${result.value}
                            ${result.expected ? `<br>Expected: ${result.expected}` : ''}
                        </div>
                    `;
                }).join('');
            }

            // Navigator Tests
            testNavigator() {
                const section = 'navigator';
                
                // User Agent
                const userAgent = navigator.userAgent;
                const isChrome120 = userAgent.includes('Chrome/120.0.0.0');
                const isWindows10 = userAgent.includes('Windows NT 10.0');
                this.addResult(section, 'User Agent', 
                    isChrome120 && isWindows10 ? 'protected' : 'exposed',
                    userAgent.substring(0, 50) + '...',
                    'Chrome 120 on Windows 10'
                );

                // Platform
                const platform = navigator.platform;
                this.addResult(section, 'Platform',
                    platform === 'Win32' ? 'protected' : 'exposed',
                    platform,
                    'Win32'
                );

                // Language
                const language = navigator.language;
                this.addResult(section, 'Language',
                    language === 'en-US' ? 'protected' : 'vulnerable',
                    language,
                    'en-US'
                );

                // Hardware Concurrency
                const cores = navigator.hardwareConcurrency;
                this.addResult(section, 'CPU Cores',
                    cores === 8 || cores === 16 ? 'protected' : 'exposed',
                    cores,
                    '8 or 16'
                );

                // Device Memory
                const memory = navigator.deviceMemory;
                this.addResult(section, 'Device Memory',
                    memory === 8 || memory === 16 ? 'protected' : 'exposed',
                    memory ? memory + ' GB' : 'undefined',
                    '8 or 16 GB'
                );

                // Vendor
                const vendor = navigator.vendor;
                this.addResult(section, 'Vendor',
                    vendor === 'Google Inc.' ? 'protected' : 'exposed',
                    vendor,
                    'Google Inc.'
                );

                // WebDriver
                const webdriver = navigator.webdriver;
                this.addResult(section, 'WebDriver',
                    webdriver === undefined ? 'protected' : 'exposed',
                    webdriver,
                    'undefined'
                );

                this.renderResults(section, 'navigator-results');
            }

            // Canvas Tests
            testCanvas() {
                const section = 'canvas';
                this.fingerprintAttempts++;
                
                try {
                    const canvas = document.getElementById('test-canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Draw test pattern
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(10, 10, 50, 30);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillText('Fingerprint Test üîç', 20, 60);
                    ctx.strokeStyle = '#0000FF';
                    ctx.strokeRect(80, 10, 50, 30);

                    // Test toDataURL
                    const dataURL1 = canvas.toDataURL();
                    const dataURL2 = canvas.toDataURL();
                    
                    const isConsistent = dataURL1 === dataURL2;
                    const isBlank = dataURL1.length < 100 || dataURL1.includes('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42m');
                    
                    this.addResult(section, 'Canvas Consistency',
                        isConsistent ? 'protected' : 'exposed',
                        isConsistent ? 'Consistent across calls' : 'Inconsistent values',
                        'Should be consistent'
                    );

                    this.addResult(section, 'Canvas Data',
                        isBlank ? 'protected' : 'vulnerable',
                        isBlank ? 'Blank/Protected data' : 'Actual canvas data exposed',
                        'Should be blank or consistent'
                    );

                    // Test getImageData
                    const imageData = ctx.getImageData(0, 0, 10, 10);
                    const hasNoise = this.hasNoise(imageData.data);
                    
                    this.addResult(section, 'Image Data Protection',
                        hasNoise || isBlank ? 'protected' : 'exposed',
                        hasNoise ? 'Noise detected' : 'No protection detected',
                        'Should have noise or be blank'
                    );

                } catch (error) {
                    this.addResult(section, 'Canvas Error',
                        'info',
                        error.message,
                        'Canvas operations should work'
                    );
                }

                this.renderResults(section, 'canvas-results');
            }

            hasNoise(data) {
                // Simple noise detection
                let variations = 0;
                for (let i = 0; i < data.length - 4; i += 4) {
                    if (Math.abs(data[i] - data[i + 4]) > 1) variations++;
                }
                return variations > data.length / 20; // More than 5% variation
            }

            // WebGL Tests
            testWebGL() {
                const section = 'webgl';
                this.fingerprintAttempts++;
                
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        this.addResult(section, 'WebGL Support', 'info', 'Not supported', 'Should be available');
                        this.renderResults(section, 'webgl-results');
                        return;
                    }

                    // Vendor
                    const vendor = gl.getParameter(gl.VENDOR);
                    this.addResult(section, 'WebGL Vendor',
                        vendor === 'Google Inc.' ? 'protected' : 'exposed',
                        vendor,
                        'Google Inc.'
                    );

                    // Renderer
                    const renderer = gl.getParameter(gl.RENDERER);
                    const hasNVIDIA = renderer.includes('NVIDIA') || renderer.includes('GeForce');
                    this.addResult(section, 'WebGL Renderer',
                        hasNVIDIA ? 'protected' : 'exposed',
                        renderer,
                        'Should include NVIDIA/GeForce'
                    );

                    // Extensions
                    const extensions = gl.getSupportedExtensions();
                    this.addResult(section, 'WebGL Extensions',
                        extensions && extensions.length > 0 ? 'info' : 'vulnerable',
                        extensions ? extensions.length + ' extensions' : 'No extensions',
                        'Should have extensions'
                    );

                    // Shader precision
                    const precision = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
                    this.addResult(section, 'Shader Precision',
                        precision ? 'info' : 'vulnerable',
                        precision ? `Precision: ${precision.precision}` : 'Not available',
                        'Should be available'
                    );

                } catch (error) {
                    this.addResult(section, 'WebGL Error',
                        'info',
                        error.message,
                        'WebGL should work'
                    );
                }

                this.renderResults(section, 'webgl-results');
            }

            // Audio Tests
            testAudio() {
                const section = 'audio';
                this.fingerprintAttempts++;
                
                try {
                    if (!window.AudioContext && !window.webkitAudioContext) {
                        this.addResult(section, 'Audio Context', 'info', 'Not supported', 'Should be available');
                        this.renderResults(section, 'audio-results');
                        return;
                    }

                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    const audioContext = new AudioContextClass();

                    // Sample Rate
                    const sampleRate = audioContext.sampleRate;
                    this.addResult(section, 'Sample Rate',
                        sampleRate === 48000 ? 'protected' : 'vulnerable',
                        sampleRate + ' Hz',
                        '48000 Hz'
                    );

                    // State
                    const state = audioContext.state;
                    this.addResult(section, 'Audio State',
                        state === 'running' || state === 'suspended' ? 'info' : 'vulnerable',
                        state,
                        'running or suspended'
                    );

                    // Base Latency
                    const baseLatency = audioContext.baseLatency;
                    this.addResult(section, 'Base Latency',
                        typeof baseLatency === 'number' ? 'info' : 'vulnerable',
                        baseLatency ? baseLatency.toFixed(6) : 'undefined',
                        'Should be a number'
                    );

                    audioContext.close();

                } catch (error) {
                    this.addResult(section, 'Audio Error',
                        'info',
                        error.message,
                        'Audio should work'
                    );
                }

                this.renderResults(section, 'audio-results');
            }

            // Font Tests
            testFonts() {
                const section = 'font';
                this.fingerprintAttempts++;
                
                const testFonts = [
                    'Arial', 'Times New Roman', 'Courier New', 'Helvetica', 
                    'Georgia', 'Verdana', 'Tahoma', 'Impact'
                ];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                let consistentMeasurements = 0;
                const measurements = [];

                testFonts.forEach(font => {
                    ctx.font = `16px ${font}`;
                    const width1 = ctx.measureText('Test string 123').width;
                    const width2 = ctx.measureText('Test string 123').width;
                    
                    measurements.push({ font, width1, width2, consistent: width1 === width2 });
                    if (width1 === width2) consistentMeasurements++;
                });

                this.addResult(section, 'Font Consistency',
                    consistentMeasurements === testFonts.length ? 'protected' : 'vulnerable',
                    `${consistentMeasurements}/${testFonts.length} fonts consistent`,
                    'All fonts should be consistent'
                );

                // Test document.fonts API
                if (document.fonts && document.fonts.check) {
                    const windowsFonts = ['Arial', 'Calibri', 'Segoe UI', 'Times New Roman'];
                    let windowsFontsAvailable = 0;
                    
                    windowsFonts.forEach(font => {
                        if (document.fonts.check(`16px ${font}`)) {
                            windowsFontsAvailable++;
                        }
                    });

                    this.addResult(section, 'Windows Fonts',
                        windowsFontsAvailable >= 3 ? 'protected' : 'vulnerable',
                        `${windowsFontsAvailable}/${windowsFonts.length} Windows fonts available`,
                        'Most Windows fonts should be available'
                    );
                }

                this.renderResults(section, 'font-results');
            }

            // Screen Tests
            testScreen() {
                const section = 'screen';
                
                // Screen dimensions
                const width = screen.width;
                const height = screen.height;
                const commonResolutions = [
                    [1920, 1080], [2560, 1440], [1366, 768], [1536, 864]
                ];
                
                const isCommonResolution = commonResolutions.some(([w, h]) => w === width && h === height);
                
                this.addResult(section, 'Screen Resolution',
                    isCommonResolution ? 'protected' : 'vulnerable',
                    `${width} x ${height}`,
                    'Should be common resolution'
                );

                // Color depth
                const colorDepth = screen.colorDepth;
                this.addResult(section, 'Color Depth',
                    colorDepth === 24 ? 'protected' : 'vulnerable',
                    colorDepth + ' bits',
                    '24 bits'
                );

                // Device pixel ratio
                const devicePixelRatio = window.devicePixelRatio;
                this.addResult(section, 'Device Pixel Ratio',
                    devicePixelRatio === 1 ? 'protected' : 'vulnerable',
                    devicePixelRatio,
                    '1'
                );

                // Available dimensions
                const availWidth = screen.availWidth;
                const availHeight = screen.availHeight;
                this.addResult(section, 'Available Screen',
                    availWidth <= width && availHeight <= height ? 'info' : 'vulnerable',
                    `${availWidth} x ${availHeight}`,
                    'Should be <= actual screen size'
                );

                this.renderResults(section, 'screen-results');
            }

            // Network Tests
            testNetwork() {
                const section = 'network';
                
                // Connection API
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if (connection) {
                    this.addResult(section, 'Connection Type',
                        connection.effectiveType === '4g' ? 'protected' : 'vulnerable',
                        connection.effectiveType || 'unknown',
                        '4g'
                    );

                    this.addResult(section, 'Connection Downlink',
                        connection.downlink === 10 ? 'protected' : 'vulnerable',
                        connection.downlink + ' Mbps',
                        '10 Mbps'
                    );
                } else {
                    this.addResult(section, 'Connection API', 'info', 'Not available', 'Should be spoofed if available');
                }

                // Online status
                const onLine = navigator.onLine;
                this.addResult(section, 'Online Status',
                    onLine ? 'info' : 'vulnerable',
                    onLine ? 'Online' : 'Offline',
                    'Should be online'
                );

                // Do Not Track
                const doNotTrack = navigator.doNotTrack;
                this.addResult(section, 'Do Not Track',
                    doNotTrack === '1' ? 'protected' : 'vulnerable',
                    doNotTrack || 'not set',
                    '1'
                );

                this.renderResults(section, 'network-results');
            }

            // Tracking Tests
            testTracking() {
                const section = 'tracking';
                
                // Test blocked requests
                const testUrls = [
                    'https://google-analytics.com/collect',
                    'https://facebook.com/tr',
                    'https://doubleclick.net/pixel'
                ];

                let blockedCount = 0;
                testUrls.forEach(url => {
                    try {
                        fetch(url, { mode: 'no-cors' })
                            .then(() => {
                                this.addResult(section, `Request to ${url.split('/')[2]}`,
                                    'exposed',
                                    'Request succeeded',
                                    'Should be blocked'
                                );
                            })
                            .catch(() => {
                                this.addResult(section, `Request to ${url.split('/')[2]}`,
                                    'protected',
                                    'Request blocked',
                                    'Should be blocked'
                                );
                                this.blockedRequests++;
                                blockedCount++;
                            });
                    } catch (error) {
                        this.addResult(section, `Request to ${url.split('/')[2]}`,
                            'protected',
                            'Request blocked by script',
                            'Should be blocked'
                        );
                        this.blockedRequests++;
                        blockedCount++;
                    }
                });

                // Test sendBeacon
                try {
                    const beaconSent = navigator.sendBeacon('https://example.com/beacon', 'test');
                    this.addResult(section, 'SendBeacon',
                        beaconSent ? 'vulnerable' : 'protected',
                        beaconSent ? 'Beacon sent' : 'Beacon blocked',
                        'Should be blocked'
                    );
                } catch (error) {
                    this.addResult(section, 'SendBeacon',
                        'protected',
                        'Beacon blocked by script',
                        'Should be blocked'
                    );
                }

                // Test referrer
                const referrer = document.referrer;
                this.addResult(section, 'Document Referrer',
                    referrer === '' ? 'protected' : 'vulnerable',
                    referrer || 'empty',
                    'Should be empty'
                );

                setTimeout(() => {
                    this.renderResults(section, 'tracking-results');
                }, 1000);
            }

            // Run all tests
            runAllTests() {
                this.results = {};
                this.testsPassed = 0;
                this.totalTests = 0;
                this.fingerprintAttempts = 0;
                this.blockedRequests = 0;

                this.testNavigator();
                this.testCanvas();
                this.testWebGL();
                this.testAudio();
                this.testFonts();
                this.testScreen();
                this.testNetwork();
                this.testTracking();

                // Check if UAF is loaded
                if (window.UltimateAntiFingerprint) {
                    const stats = window.UltimateAntiFingerprint.stats();
                    this.addResult('system', 'UAF Status', 'info', 
                        `Loaded v${window.UltimateAntiFingerprint.version}`, 
                        'Should be loaded');
                    this.addResult('system', 'UAF Runtime', 'info', 
                        `${Math.round(stats.runtime / 1000)}s`, 
                        'Runtime information');
                    this.addResult('system', 'UAF Protections', 'info', 
                        `${stats.protection_activations} active`, 
                        'Protection count');
                }
            }

            exportResults() {
                const data = {
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    testResults: this.results,
                    stats: {
                        testsPassed: this.testsPassed,
                        totalTests: this.totalTests,
                        protectionScore: Math.round((this.testsPassed / this.totalTests) * 100),
                        fingerprintAttempts: this.fingerprintAttempts,
                        blockedRequests: this.blockedRequests
                    }
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fingerprint-test-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearResults() {
                const resultContainers = [
                    'navigator-results', 'canvas-results', 'webgl-results', 
                    'audio-results', 'font-results', 'screen-results', 
                    'network-results', 'tracking-results'
                ];
                
                resultContainers.forEach(id => {
                    document.getElementById(id).innerHTML = '';
                });

                this.results = {};
                this.testsPassed = 0;
                this.totalTests = 0;
                this.fingerprintAttempts = 0;
                this.blockedRequests = 0;
                this.updateStats();
            }
        }

        // Initialize tester
        const tester = new FingerprintTester();

        // Global functions
        function runAllTests() {
            tester.runAllTests();
        }

        function clearResults() {
            tester.clearResults();
        }

        function exportResults() {
            tester.exportResults();
        }

        // Auto-run tests on load
        window.addEventListener('load', () => {
            setTimeout(() => {
                runAllTests();
            }, 1000);
        });
    </script>
</body>
</html>